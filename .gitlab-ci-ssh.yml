stages:
  - pre_merge
  - check_merge_status

pre_merge_job:
  stage: pre_merge
  variables:
    GIT_TERMINAL_PROMPT: "0"
  script:
    # Get the source branch name from the merge request
    - SOURCE_BRANCH=$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - echo "Source branch" $SOURCE_BRANCH
    - echo "Target branch:" $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
    - echo "MR Title:" $CI_MERGE_REQUEST_TITLE
    
    # Configure git
    - git config --global user.email "16069257+KennyTC@users.noreply.github.com"
    - git config --global user.name "GitLab Bot"
    
    # Setup SSH for GitHub
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    # Write the SSH key - handle both File and Variable types
    - |
      if [ -f "$GITHUB_SSH_PRIVATE_KEY" ]; then
        # If it's a file type variable
        echo "SSH key is a file, copying..."
        cp "$GITHUB_SSH_PRIVATE_KEY" ~/.ssh/id_rsa
      else
        # If it's a regular variable, write it (remove carriage returns)
        echo "SSH key is a variable, writing..."
        echo "$GITHUB_SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
      fi
    - chmod 600 ~/.ssh/id_rsa
    # Add GitHub to known hosts
    - ssh-keyscan github.com >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
    - echo "SSH key configured"

    # Debug: Check SSH key
    # - echo "Checking SSH private key file..."
    # - ls -la ~/.ssh/
    # - echo "First line of private key:"
    # - head -n 1 ~/.ssh/id_rsa
    # - echo "Last line of private key:"
    # - tail -n 1 ~/.ssh/id_rsa
    # - echo "SSH key fingerprint:"
    # - ssh-keygen -l -f ~/.ssh/id_rsa || echo "Failed to get fingerprint"
    
    # Debug: Check SSH key
    - echo "Checking SSH private key file..."
    - ls -la ~/.ssh/
    - echo "Number of lines in key file:"
    - wc -l ~/.ssh/id_rsa
    - echo "First line of private key:"
    - head -n 1 ~/.ssh/id_rsa
    - echo "Last line of private key:"
    - tail -n 1 ~/.ssh/id_rsa
    - echo "Checking for carriage returns or special characters:"
    - cat -A ~/.ssh/id_rsa | head -n 3
    - echo "SSH key fingerprint:"
    - ssh-keygen -l -f ~/.ssh/id_rsa 2>&1 || echo "Failed to get fingerprint - key may be invalid"
    
    # Test SSH connection with verbose output
    - echo "Testing SSH connection to GitHub..."
    - ssh -vT git@github.com 2>&1 || true
    
    # Add GitHub remote using SSH
    - git remote add github git@github.com:KennyTC/sync_from_gitlab.git || git remote set-url github git@github.com:KennyTC/sync_from_gitlab.git
    
    # Fetch from GitHub
    - git fetch github
    
    # # Test push - create a simple test file and push to GitHub
    # - echo "Testing SSH authentication to GitHub at $(date)" > test_push_ssh.txt
    # - git checkout -b test-push-ssh-branch
    # - git add test_push_ssh.txt
    # - git commit -m "Test SSH push from GitLab CI"
    # - git push github test-push-ssh-branch
    # - echo "Test SSH push successful!"
    
    # Checkout GitHub main branch
    - git checkout -b temp-github-main github/main
    
    # Fetch the source branch that will be merged
    - git fetch origin $SOURCE_BRANCH
    
    # Get the current state of the target branch (develop/2025)
    - git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
    
    # Simulate the merge that will happen on develop/2025
    - git checkout temp-github-main
    - git merge --no-ff --allow-unrelated-histories origin/$SOURCE_BRANCH -m "Sync from GitLab"
    
    # Create release branch based on the source branch name
    - RELEASE_BRANCH="release/$SOURCE_BRANCH"
    - git checkout -b $RELEASE_BRANCH
    
    # Push the release branch to GitHub using SSH
    - git push github $RELEASE_BRANCH
    
    # Create a Pull Request using GitHub API
    - echo "Creating pull request on GitHub..."
    # Check if GITHUB_TOKEN is set
    - |
      if [ -z "$GITHUB_TOKEN" ]; then
        echo "ERROR: GITHUB_TOKEN is not set. Cannot create pull request."
        exit 1
      fi
    - echo "GITHUB_TOKEN is set " $GITHUB_TOKEN
    - COMMIT_LIST=$(git log origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME..origin/$SOURCE_BRANCH --pretty=format:'%h %s')
    - PR_RESPONSE=$(curl -s -X POST -H "Authorization:token ${GITHUB_TOKEN}" -H "Accept:application/vnd.github.v3+json" https://api.github.com/repos/KennyTC/sync_from_gitlab/pulls -d "{\"title\":\"Sync from GitLab:$SOURCE_BRANCH\",\"head\":\"$RELEASE_BRANCH\",\"base\":\"main\",\"body\":\"Automated sync from GitLab.\\n\\nSource branch:\`$SOURCE_BRANCH\`\\nMerged into:\`$CI_COMMIT_REF_NAME\`\\n\\nCommits:\\n\`\`\`\\n$COMMIT_LIST\\n\`\`\`\"}")
    - echo "$PR_RESPONSE"
    
    # Extract PR number and URL from response
    - PR_NUMBER=$(echo "$PR_RESPONSE" | grep -o '"number":[0-9]*' | grep -o '[0-9]*' | head -1)
    - PR_URL=$(echo "$PR_RESPONSE" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
    - echo "✅ Pull Request created successfully!"
    - echo "📝 PR Number: $PR_NUMBER"
    - echo "🔗 PR URL: $PR_URL"
    - echo "PR_NUMBER=$PR_NUMBER" >> pr_info.env
    - echo "RELEASE_BRANCH=$RELEASE_BRANCH" >> pr_info.env
    - echo "SOURCE_BRANCH=$SOURCE_BRANCH" >> pr_info.env
  artifacts:
    reports:
      dotenv: pr_info.env
    expire_in: 30 days
  
  
  rules:
    # Only run for merge requests targeting develop/2025
    # Requires manual trigger - click "Play" button after MR is approved
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "develop/2025"
      when: manual

check_github_pr_status:
  stage: check_merge_status
  variables:
    GIT_TERMINAL_PROMPT: "0"
  script:
    - echo "Checking GitHub PR merge status..."
    - echo "PR Number: $PR_NUMBER"
    - echo "Source Branch: $SOURCE_BRANCH"
    - echo "Release Branch: $RELEASE_BRANCH"
    
    # Check if GITHUB_TOKEN is set
    - |
      if [ -z "$GITHUB_TOKEN" ]; then
        echo "ERROR: GITHUB_TOKEN is not set."
        exit 1
      fi
    
    # Check if PR_NUMBER exists
    - |
      if [ -z "$PR_NUMBER" ]; then
        echo "ERROR: PR_NUMBER not found. Make sure pre_merge_job completed successfully."
        exit 1
      fi
    
    # Query GitHub API for PR status
    - PR_STATUS=$(curl -s -H "Authorization:token ${GITHUB_TOKEN}" -H "Accept:application/vnd.github.v3+json" https://api.github.com/repos/KennyTC/sync_from_gitlab/pulls/$PR_NUMBER)
    - echo "PR Status Response:"
    - echo "$PR_STATUS" | grep -E '"state"|"merged"|"closed_at"|"merged_at"'
    
    # Check if PR is merged
    - MERGED=$(echo "$PR_STATUS" | grep -o '"merged":true')
    - STATE=$(echo "$PR_STATUS" | grep -o '"state":"[^"]*"' | cut -d'"' -f4)
    - MERGED_AT=$(echo "$PR_STATUS" | grep -o '"merged_at":"[^"]*"' | cut -d'"' -f4)
    
    # Signal based on merge status
    - |
      if [ "$MERGED" = '"merged":true' ] || [ ! -z "$MERGED_AT" ]; then
        echo ""
        echo "🎉🎉🎉 SUCCESS! 🎉🎉🎉"
        echo "=========================================="
        echo "✅ GitHub Pull Request #$PR_NUMBER has been MERGED!"
        echo "🔗 Branch: $RELEASE_BRANCH"
        echo "📅 Merged at: $MERGED_AT"
        echo "=========================================="
        echo ""
        echo "The changes from GitLab branch '$SOURCE_BRANCH' are now in GitHub main branch!"
        exit 0
      elif [ "$STATE" = "closed" ]; then
        echo ""
        echo "❌ GitHub Pull Request #$PR_NUMBER was CLOSED without merging."
        echo "State: $STATE"
        exit 1
      elif [ "$STATE" = "open" ]; then
        echo ""
        echo "⏳ GitHub Pull Request #$PR_NUMBER is still OPEN."
        echo "Waiting for merge approval on GitHub..."
        exit 1
      else
        echo ""
        echo "⚠️ Unable to determine PR status. Response:"
        echo "$PR_STATUS"
        exit 1
      fi
  
  dependencies:
    - pre_merge_job
  
  rules:
    # Can be triggered manually anytime after pre_merge_job
    # Or set up a scheduled pipeline to check periodically
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "develop/2025"
      when: manual
      allow_failure: true
    # Uncomment below to run on schedule (set up in CI/CD > Schedules)
    # - if: $CI_PIPELINE_SOURCE == "schedule"
    #   when: always